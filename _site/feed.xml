<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-08-31T17:32:43+08:00</updated><id>http://localhost:4000/</id><title type="html">voltel</title><subtitle>Do something not like me!</subtitle><entry><title type="html">notes</title><link href="http://localhost:4000/learn/2018/08/31/notes.html" rel="alternate" type="text/html" title="notes" /><published>2018-08-31T10:30:07+08:00</published><updated>2018-08-31T10:30:07+08:00</updated><id>http://localhost:4000/learn/2018/08/31/notes</id><content type="html" xml:base="http://localhost:4000/learn/2018/08/31/notes.html">&lt;p&gt;_source :[]  返回全部的字段，id:”“,自动创建一个id值&lt;/p&gt;

&lt;p&gt;DAO :data access object&lt;/p&gt;

&lt;p&gt;1.当项目在服务器上启动时，我们在浏览器上输入https://localhost:8080/项目名/hello，tomcat服务器会根据加载的web.xml，找到url-pattern进行拦截，并交给配置好的名字为HelloWeb的这个servlet，真实的类是DispatcherServlet；
2.然后DispatcherServlet根据相应的配置文件HelloWeb-servlet.xml，由于配置了自动扫描context:component-scan，所以自动识别到controller；
3.然后spring的HandlerMapping根据@RequestMapping，将url根目录后面的子路径进行匹配，找到HelloController，并交给默认的printHello()方法运行；
4.运行结果返回的”hello”被解析为对应视图显示&lt;/p&gt;

&lt;p&gt;先加载web.xml，根据url-pattern 进行拦截，将其交给定义好的servlet，servlet配置的类名为DispatcherServlet，再去找 DispatcherServlet配置的servlet.xml，识别controller，根据controller中的RequestMapping，将url后面的子路径进行匹配,运行完返回给对应的试图(view)&lt;/p&gt;

&lt;p&gt;@RequestMapping(value = “/index”, method = RequestMethod.GET) value :路径，method:请求的方式&lt;/p&gt;</content><author><name></name></author><summary type="html">_source :[] 返回全部的字段，id:”“,自动创建一个id值</summary></entry><entry><title type="html">备用</title><link href="http://localhost:4000/notes/2018/08/30/text.html" rel="alternate" type="text/html" title="备用" /><published>2018-08-30T12:30:07+08:00</published><updated>2018-08-30T12:30:07+08:00</updated><id>http://localhost:4000/notes/2018/08/30/text</id><content type="html" xml:base="http://localhost:4000/notes/2018/08/30/text.html">&lt;p&gt;nohup 直接关闭命令窗口，导致程序退出，使用exit进行退出，防止程序退出。&lt;/p&gt;

&lt;p&gt;grep ‘要查找的内容’  文件名  实现查找 very very importent&lt;/p&gt;

&lt;p&gt;mcp 复制文件 root@node-d:&lt;/p&gt;

&lt;p&gt;wc -l filename  显示统计文件的行数&lt;/p&gt;

&lt;p&gt;ftp ip port&lt;/p&gt;

&lt;p&gt;find . -name “” print 对文件进行查找&lt;/p&gt;</content><author><name></name></author><summary type="html">nohup 直接关闭命令窗口，导致程序退出，使用exit进行退出，防止程序退出。</summary></entry><entry><title type="html">欢迎!</title><link href="http://localhost:4000/wellcome/2018/08/25/welcome-to-jekyll.html" rel="alternate" type="text/html" title="欢迎!" /><published>2018-08-25T19:30:07+08:00</published><updated>2018-08-25T19:30:07+08:00</updated><id>http://localhost:4000/wellcome/2018/08/25/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/wellcome/2018/08/25/welcome-to-jekyll.html">&lt;p&gt;欢迎来到这里，页面是用jekyll 构建的。&lt;/p&gt;</content><author><name></name></author><summary type="html">欢迎来到这里，页面是用jekyll 构建的。</summary></entry></feed>